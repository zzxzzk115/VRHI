# VRHI v1.0 开发路线图

**目标**: 通过可工作、可编译、可运行的代码骨架验证可行性，展示核心架构。

---

## 阶段 1: 基础设施与构建系统 (第 1-2 周)

**目标**: 建立项目结构、构建系统和最小编译能力。

### 任务
1. **项目结构**
   - 创建目录布局: `src/`, `include/`, `external/`, `examples/`, `tests/`
   - 设置 CMake 根配置 (CMakeLists.txt)
   - 配置 C++23 编译器要求
   - 添加 `.gitignore` 排除构建产物

2. **构建系统**
   - 实现模块化 CMakeLists.txt 结构
   - 添加平台检测 (Windows/Linux/macOS)
   - 创建后端选择的构建选项
   - 设置安装/导出目标

3. **CI/CD 流水线**
   - Linux 的 GitHub Actions 工作流 (GCC, Clang)
   - Windows 的 GitHub Actions 工作流 (MSVC)
   - macOS 的 GitHub Actions 工作流 (AppleClang)
   - Debug/Release 配置的矩阵构建

### 验收标准
- ✅ 项目在 Windows、Linux 和 macOS 上编译成功
- ✅ CMake 生成构建文件无错误
- ✅ CI 流水线在所有平台上通过
- ✅ 空库目标成功链接
- ✅ 基础示例程序编译并运行（打印 "Hello VRHI"）

**交付物**: 可编译的空骨架，带有工作的构建系统

---

## 阶段 2: 核心接口与错误处理 (第 3-4 周)

**目标**: 实现核心类型、错误处理和基本设备抽象。

### 任务
1. **错误处理**
   - 实现带错误码的 `Error` 类
   - 添加 `std::expected` 返回类型
   - 创建错误消息格式化工具

2. **核心类型**
   - 定义 `BackendType` 枚举
   - 实现能力查询的 `Feature` 枚举
   - 创建 `FeatureRequirements` 结构
   - 定义 `DeviceConfig` 配置结构

3. **设备接口**
   - 定义 `IDevice` 抽象基类
   - 定义 `IBackend` 抽象基类
   - 实现设备工厂模式骨架
   - 添加后端枚举函数签名

4. **RAII 包装器**
   - 创建句柄包装模板
   - 实现资源的智能指针别名
   - 添加移动语义支持

### 验收标准
- ✅ 所有头文件无错误编译
- ✅ 错误类型可以创建和格式化
- ✅ `std::expected` 返回值正常工作
- ✅ 设备接口定义清晰且有文档
- ✅ 错误处理单元测试通过
- ✅ 示例程序创建模拟设备并处理错误

**交付物**: 完整的类型系统和错误处理，尚无后端实现

---

## 阶段 3: 后端工厂与选择 (第 5-6 周)

**目标**: 实现后端枚举、评分和自动选择。

### 任务
1. **后端注册表**
   - 实现后端注册系统
   - 创建后端实例化的工厂类
   - 添加后端枚举逻辑

2. **特性检测框架**
   - 定义特性支持查询接口
   - 实现特性需求验证
   - 添加缺失特性的错误报告

3. **后端评分**
   - 实现评分算法（40% 特性，30% 性能，20% 稳定性，10% 兼容性）
   - 添加平台原生 API 加分计算
   - 创建后端比较和选择逻辑

4. **模拟后端**
   - 实现用于测试的 `MockBackend`
   - 添加可配置的特性支持
   - 创建模拟设备实现

### 验收标准
- ✅ 后端枚举返回可用后端列表
- ✅ 评分算法正确排序后端
- ✅ 特性验证拒绝不兼容的后端
- ✅ 平台原生加分正确应用（在 Windows/Linux/macOS 上验证）
- ✅ 模拟后端注册并可被选择
- ✅ 示例程序枚举后端并显示分数
- ✅ 选择逻辑的单元测试通过

**交付物**: 工作的后端选择系统，带有模拟后端

---

## 阶段 4: OpenGL 3.3 后端 (第 7-9 周)

**目标**: 实现首个真实后端（OpenGL 3.3），具备最小渲染能力。

### 任务
1. **OpenGL 上下文创建**
   - 集成 GLFW 窗口系统（添加到 `external/`）
   - 实现 OpenGL 上下文创建
   - 添加扩展加载（GLAD 或类似）

2. **OpenGL 后端实现**
   - 实现 `OpenGL33Backend` 类
   - 创建 `OpenGL33Device` 类
   - 实现 GL 3.3 的特性支持查询

3. **基础资源管理**
   - 实现缓冲区创建（顶点/索引缓冲区）
   - 添加纹理创建（2D 纹理）
   - 实现着色器编译和链接
   - 创建管线状态对象包装

4. **命令记录**
   - 实现命令缓冲区抽象
   - 添加绘制调用记录
   - 创建简单的命令提交

### 验收标准
- ✅ OpenGL 3.3 上下文在所有平台上创建成功
- ✅ 设备创建返回有效的 OpenGL 设备
- ✅ 可以创建并绑定顶点缓冲区
- ✅ 可以创建并绑定纹理
- ✅ 可以编译并链接简单着色器程序
- ✅ 示例程序渲染彩色三角形到窗口
- ✅ 执行期间无 OpenGL 错误
- ✅ OpenGL 后端的集成测试通过

**交付物**: 可渲染三角形的 OpenGL 3.3 后端

---

## 阶段 5: 资源管理与 RAII (第 10-11 周)

**目标**: 完成资源生命周期管理，具备适当的 RAII。

### 任务
1. **缓冲区管理**
   - 实现带 RAII 语义的 `Buffer` 类
   - 添加缓冲区映射/解映射
   - 实现缓冲区用途标志
   - 添加缓冲区更新操作

2. **纹理管理**
   - 实现带 RAII 的 `Texture` 类
   - 添加纹理格式支持
   - 实现纹理上传操作
   - 添加 mipmap 生成

3. **着色器与管线管理**
   - 实现 `Shader` 类
   - 创建带 RAII 的 `Pipeline` 类
   - 添加管线状态管理
   - 实现着色器反射（基础）

4. **资源生命周期**
   - 确保正确的销毁顺序
   - 在需要时添加引用计数
   - 实现资源状态跟踪

### 验收标准
- ✅ 资源在销毁时自动释放
- ✅ 无内存泄漏（通过 Valgrind/ASAN 验证）
- ✅ 缓冲区更新操作正常工作
- ✅ 纹理上传和采样工作正常
- ✅ 管线状态更改正确应用
- ✅ 示例程序在循环中创建/销毁资源无泄漏
- ✅ 资源生命周期单元测试通过

**交付物**: 完整的资源管理系统，具有 RAII 保证

---

## 阶段 6: Vulkan 后端骨架 (第 12-13 周)

**目标**: 添加 Vulkan 后端以验证多后端架构。

### 任务
1. **Vulkan 集成**
   - 在 CMake 中添加 Vulkan SDK 检测
   - 集成 Vulkan 头文件
   - 实现 Vulkan 实例创建

2. **Vulkan 后端**
   - 实现 `VulkanBackend` 类
   - 创建 `VulkanDevice` 类
   - 添加物理设备选择逻辑
   - 实现 Vulkan 的特性支持查询

3. **基础 Vulkan 资源**
   - 实现缓冲区创建
   - 添加纹理创建
   - 实现着色器模块创建
   - 创建管线创建

4. **命令记录**
   - 实现命令缓冲区分配
   - 添加命令记录
   - 创建命令提交

### 验收标准
- ✅ Vulkan 后端在所有平台上编译（如果 SDK 不可用则跳过）
- ✅ 后端枚举显示 OpenGL 和 Vulkan
- ✅ 评分在桌面系统上优先选择 Vulkan
- ✅ 可以在支持 Vulkan 的系统上创建 Vulkan 设备
- ✅ 基础三角形使用 Vulkan 后端渲染
- ✅ 相同的示例代码可用于 OpenGL 和 Vulkan
- ✅ 可以通过配置手动选择后端

**交付物**: 与 OpenGL 并存的 Vulkan 后端，验证架构灵活性

---

## 阶段 7: 窗口系统抽象 (第 14-15 周)

**目标**: 抽象窗口系统以支持多种实现。

### 任务
1. **窗口接口**
   - 定义 `IWindow` 抽象接口
   - 实现窗口配置结构
   - 添加平台无关的事件类型

2. **GLFW 实现**
   - 实现 `GLFWWindow` 类
   - 添加事件回调系统
   - 实现键码转换
   - 添加 OpenGL 和 Vulkan 的表面创建

3. **窗口工厂**
   - 实现 `WindowFactory` 类
   - 添加自动窗口系统选择
   - 创建手动窗口系统指定

4. **事件系统**
   - 实现事件队列
   - 添加轮询和回调模式
   - 创建平台无关的键码

### 验收标准
- ✅ 窗口在所有平台上创建成功
- ✅ 正确接收事件（键盘、鼠标）
- ✅ 键码转换在各平台上工作
- ✅ 轮询和回调模式都工作
- ✅ 可以从同一窗口创建 OpenGL 和 Vulkan 表面
- ✅ 示例程序使用窗口抽象
- ✅ 窗口调整大小事件正确处理

**交付物**: 完整的窗口系统抽象，带有 GLFW 实现

---

## 阶段 8: 示例应用程序 (第 16 周)

**目标**: 创建演示所有功能的综合示例。

### 任务
1. **Hello Triangle**
   - 简单的彩色三角形
   - 演示基础渲染
   - 适用于两个后端

2. **纹理立方体**
   - 带纹理的旋转 3D 立方体
   - 演示 3D 渲染和纹理
   - 使用顶点和索引缓冲区

3. **特性检测演示**
   - 显示后端枚举
   - 显示每个后端的特性支持
   - 演示必需特性验证

4. **多后端演示**
   - 允许运行时后端切换
   - 比较后端间的性能
   - 显示后端评分

### 验收标准
- ✅ 所有示例在 Windows/Linux/macOS 上编译并运行
- ✅ 示例适用于 OpenGL 和 Vulkan 后端
- ✅ 清晰的控制台输出显示后端选择
- ✅ 视觉输出符合预期
- ✅ 执行期间无崩溃或错误
- ✅ 示例有清晰注释解释概念

**交付物**: 4 个演示所有 v1.0 功能的示例应用程序

---

## 阶段 9: 测试与文档 (第 17-18 周)

**目标**: 全面测试和文档完善。

### 任务
1. **单元测试**
   - 核心类型测试（Error、Expected 等）
   - 后端选择测试
   - 特性验证测试
   - 资源生命周期测试
   - 达到 >80% 代码覆盖率

2. **集成测试**
   - 端到端渲染测试
   - 多后端测试
   - 资源压力测试
   - 窗口系统测试

3. **文档**
   - API 参考生成（Doxygen）
   - 教程文档
   - 从原始 API 的迁移指南
   - 性能最佳实践

4. **验证**
   - 内存泄漏检测（Valgrind/ASAN）
   - 线程安全分析
   - API 使用验证
   - 跨平台验证

### 验收标准
- ✅ 所有单元测试在所有平台上通过
- ✅ 集成测试在所有平台上通过
- ✅ 代码覆盖率 >80%
- ✅ 无内存泄漏检测
- ✅ 无线程问题检测
- ✅ 文档构建成功
- ✅ 所有公共 API 有文档
- ✅ 教程可以从头到尾跟随

**交付物**: 全面测试和文档化的 v1.0 代码库

---

## 阶段 10: 打磨与发布 (第 19-20 周)

**目标**: 最终打磨和 v1.0 发布准备。

### 任务
1. **性能优化**
   - 分析热点路径
   - 优化后端选择
   - 减少分配开销
   - 与原始 API 对比基准测试

2. **代码质量**
   - 运行静态分析（clang-tidy、cppcheck）
   - 修复所有警告
   - 应用一致的格式化（clang-format）
   - 代码审查

3. **发布准备**
   - 创建 CHANGELOG.md
   - 更新 README 功能说明
   - 创建发布构建
   - 打包示例和文档

4. **最终验证**
   - 在干净系统上测试
   - 验证安装过程
   - 检查所有示例工作
   - 最终跨平台验证

### 验收标准
- ✅ 所有静态分析无错误通过
- ✅ 所有平台零编译器警告
- ✅ 性能在原始 API 开销的 5% 以内
- ✅ 通过 CMake 安装正常工作
- ✅ 为所有平台创建发布构建
- ✅ 所有文档是最新的
- ✅ CHANGELOG 准确反映所有更改
- ✅ 示例在全新安装上工作

**交付物**: VRHI v1.0 发布，可用于生产

---

## 总结: v1.0 范围

### 包含的功能
- ✅ 带 `std::expected` 错误处理的核心 API
- ✅ 带工厂模式的后端抽象
- ✅ 带评分的自动后端选择
- ✅ 必需特性验证
- ✅ OpenGL 3.3 后端（完整实现）
- ✅ Vulkan 后端（基础实现）
- ✅ 窗口系统抽象（GLFW）
- ✅ 带 RAII 的资源管理（Buffer、Texture、Shader、Pipeline）
- ✅ 命令记录和提交
- ✅ 跨平台支持（Windows、Linux、macOS）
- ✅ 综合示例
- ✅ 完整测试覆盖
- ✅ 完整文档

### 推迟到未来版本
- ⏸️ Direct3D 12 后端（v2.0）
- ⏸️ Metal 后端（v2.0）
- ⏸️ WebGPU 后端（v3.0）
- ⏸️ OpenGL ES 3.0/3.1 后端（v1.1）
- ⏸️ 其他窗口系统（SDL2、SDL3、EGL）（v1.1）
- ⏸️ 高级功能（计算着色器、光线追踪）（v2.0）
- ⏸️ 多线程优化（v1.2）
- ⏸️ 全面的着色器反射（v1.2）

### 成功指标
- **编译**: 在 Windows、Linux、macOS 上无警告干净编译
- **功能**: 三角形和纹理立方体在两个后端上正确渲染
- **性能**: 相比原始 API 调用 <5% 开销
- **可靠性**: 示例程序 1000 次迭代零崩溃
- **质量**: >80% 代码覆盖率，零内存泄漏，零线程问题
- **可用性**: 开发者可以用 <100 行代码创建渲染应用程序

---

## 时间线

**总时长**: 20 周（约 5 个月）

- **第 1-2 月**: 基础 + 核心（阶段 1-3）
- **第 3-4 月**: 后端 + 资源（阶段 4-7）
- **第 5 月**: 示例 + 测试 + 发布（阶段 8-10）

**里程碑**:
- **M1**（第 6 周）: 核心 API 完成，带模拟后端
- **M2**（第 11 周）: OpenGL 后端，完整资源管理
- **M3**（第 15 周）: 多后端支持，带窗口抽象
- **M4**（第 20 周）: **v1.0 发布**
